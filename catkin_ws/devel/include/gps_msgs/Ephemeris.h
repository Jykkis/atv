// Generated by gencpp from file gps_msgs/Ephemeris.msg
// DO NOT EDIT!


#ifndef GPS_MSGS_MESSAGE_EPHEMERIS_H
#define GPS_MSGS_MESSAGE_EPHEMERIS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace gps_msgs
{
template <class ContainerAllocator>
struct Ephemeris_
{
  typedef Ephemeris_<ContainerAllocator> Type;

  Ephemeris_()
    : header()
    , seq(0)
    , stamp()
    , frame_id()
    , gps_id()
    , gps_time(0.0)
    , obs(0)
    , prn()
    , health()
    , semimajor_axis()
    , mean_anomaly()
    , eccentricity()
    , perigee_arg()
    , cos_latitude()
    , sin_latitude()
    , cos_orbit_radius()
    , sin_orbit_radius()
    , cos_inclination()
    , sin_inclination()
    , inclination_angle()
    , right_ascension()
    , mean_motion_diff()
    , inclination_rate()
    , ascension_rate()
    , time_of_week()
    , reference_time()
    , clock_correction()
    , group_delay()
    , clock_aging_1()
    , clock_aging_2()
    , clock_aging_3()  {
      prn.assign(0);

      health.assign(0);

      semimajor_axis.assign(0.0);

      mean_anomaly.assign(0.0);

      eccentricity.assign(0.0);

      perigee_arg.assign(0.0);

      cos_latitude.assign(0.0);

      sin_latitude.assign(0.0);

      cos_orbit_radius.assign(0.0);

      sin_orbit_radius.assign(0.0);

      cos_inclination.assign(0.0);

      sin_inclination.assign(0.0);

      inclination_angle.assign(0.0);

      right_ascension.assign(0.0);

      mean_motion_diff.assign(0.0);

      inclination_rate.assign(0.0);

      ascension_rate.assign(0.0);

      time_of_week.assign(0.0);

      reference_time.assign(0.0);

      clock_correction.assign(0.0);

      group_delay.assign(0.0);

      clock_aging_1.assign(0.0);

      clock_aging_2.assign(0.0);

      clock_aging_3.assign(0.0);
  }
  Ephemeris_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , seq(0)
    , stamp()
    , frame_id(_alloc)
    , gps_id(_alloc)
    , gps_time(0.0)
    , obs(0)
    , prn()
    , health()
    , semimajor_axis()
    , mean_anomaly()
    , eccentricity()
    , perigee_arg()
    , cos_latitude()
    , sin_latitude()
    , cos_orbit_radius()
    , sin_orbit_radius()
    , cos_inclination()
    , sin_inclination()
    , inclination_angle()
    , right_ascension()
    , mean_motion_diff()
    , inclination_rate()
    , ascension_rate()
    , time_of_week()
    , reference_time()
    , clock_correction()
    , group_delay()
    , clock_aging_1()
    , clock_aging_2()
    , clock_aging_3()  {
  (void)_alloc;
      prn.assign(0);

      health.assign(0);

      semimajor_axis.assign(0.0);

      mean_anomaly.assign(0.0);

      eccentricity.assign(0.0);

      perigee_arg.assign(0.0);

      cos_latitude.assign(0.0);

      sin_latitude.assign(0.0);

      cos_orbit_radius.assign(0.0);

      sin_orbit_radius.assign(0.0);

      cos_inclination.assign(0.0);

      sin_inclination.assign(0.0);

      inclination_angle.assign(0.0);

      right_ascension.assign(0.0);

      mean_motion_diff.assign(0.0);

      inclination_rate.assign(0.0);

      ascension_rate.assign(0.0);

      time_of_week.assign(0.0);

      reference_time.assign(0.0);

      clock_correction.assign(0.0);

      group_delay.assign(0.0);

      clock_aging_1.assign(0.0);

      clock_aging_2.assign(0.0);

      clock_aging_3.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _seq_type;
  _seq_type seq;

   typedef ros::Time _stamp_type;
  _stamp_type stamp;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _frame_id_type;
  _frame_id_type frame_id;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _gps_id_type;
  _gps_id_type gps_id;

   typedef double _gps_time_type;
  _gps_time_type gps_time;

   typedef int8_t _obs_type;
  _obs_type obs;

   typedef boost::array<int8_t, 33>  _prn_type;
  _prn_type prn;

   typedef boost::array<int8_t, 33>  _health_type;
  _health_type health;

   typedef boost::array<double, 33>  _semimajor_axis_type;
  _semimajor_axis_type semimajor_axis;

   typedef boost::array<double, 33>  _mean_anomaly_type;
  _mean_anomaly_type mean_anomaly;

   typedef boost::array<double, 33>  _eccentricity_type;
  _eccentricity_type eccentricity;

   typedef boost::array<double, 33>  _perigee_arg_type;
  _perigee_arg_type perigee_arg;

   typedef boost::array<double, 33>  _cos_latitude_type;
  _cos_latitude_type cos_latitude;

   typedef boost::array<double, 33>  _sin_latitude_type;
  _sin_latitude_type sin_latitude;

   typedef boost::array<double, 33>  _cos_orbit_radius_type;
  _cos_orbit_radius_type cos_orbit_radius;

   typedef boost::array<double, 33>  _sin_orbit_radius_type;
  _sin_orbit_radius_type sin_orbit_radius;

   typedef boost::array<double, 33>  _cos_inclination_type;
  _cos_inclination_type cos_inclination;

   typedef boost::array<double, 33>  _sin_inclination_type;
  _sin_inclination_type sin_inclination;

   typedef boost::array<double, 33>  _inclination_angle_type;
  _inclination_angle_type inclination_angle;

   typedef boost::array<double, 33>  _right_ascension_type;
  _right_ascension_type right_ascension;

   typedef boost::array<double, 33>  _mean_motion_diff_type;
  _mean_motion_diff_type mean_motion_diff;

   typedef boost::array<double, 33>  _inclination_rate_type;
  _inclination_rate_type inclination_rate;

   typedef boost::array<double, 33>  _ascension_rate_type;
  _ascension_rate_type ascension_rate;

   typedef boost::array<double, 33>  _time_of_week_type;
  _time_of_week_type time_of_week;

   typedef boost::array<double, 33>  _reference_time_type;
  _reference_time_type reference_time;

   typedef boost::array<double, 33>  _clock_correction_type;
  _clock_correction_type clock_correction;

   typedef boost::array<double, 33>  _group_delay_type;
  _group_delay_type group_delay;

   typedef boost::array<double, 33>  _clock_aging_1_type;
  _clock_aging_1_type clock_aging_1;

   typedef boost::array<double, 33>  _clock_aging_2_type;
  _clock_aging_2_type clock_aging_2;

   typedef boost::array<double, 33>  _clock_aging_3_type;
  _clock_aging_3_type clock_aging_3;




  typedef boost::shared_ptr< ::gps_msgs::Ephemeris_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::gps_msgs::Ephemeris_<ContainerAllocator> const> ConstPtr;

}; // struct Ephemeris_

typedef ::gps_msgs::Ephemeris_<std::allocator<void> > Ephemeris;

typedef boost::shared_ptr< ::gps_msgs::Ephemeris > EphemerisPtr;
typedef boost::shared_ptr< ::gps_msgs::Ephemeris const> EphemerisConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::gps_msgs::Ephemeris_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::gps_msgs::Ephemeris_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace gps_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/jade/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/jade/share/geometry_msgs/cmake/../msg'], 'sensor_msgs': ['/opt/ros/jade/share/sensor_msgs/cmake/../msg'], 'gps_msgs': ['/home/atv/atv-project-2017/catkin_ws/src/gps_msgs/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::gps_msgs::Ephemeris_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::gps_msgs::Ephemeris_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gps_msgs::Ephemeris_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gps_msgs::Ephemeris_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gps_msgs::Ephemeris_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gps_msgs::Ephemeris_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::gps_msgs::Ephemeris_<ContainerAllocator> >
{
  static const char* value()
  {
    return "4e93179ee4a59fd3267f8021405bbe35";
  }

  static const char* value(const ::gps_msgs::Ephemeris_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x4e93179ee4a59fd3ULL;
  static const uint64_t static_value2 = 0x267f8021405bbe35ULL;
};

template<class ContainerAllocator>
struct DataType< ::gps_msgs::Ephemeris_<ContainerAllocator> >
{
  static const char* value()
  {
    return "gps_msgs/Ephemeris";
  }

  static const char* value(const ::gps_msgs::Ephemeris_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::gps_msgs::Ephemeris_<ContainerAllocator> >
{
  static const char* value()
  {
    return "## Ephemeris Data for each satellite\n\
\n\
## There are 33 ephemeris channels so that the element number will correspond to\n\
##  the PRN number\n\
\n\
Header header\n\
    uint32 seq\n\
    time stamp\n\
    string frame_id\n\
\n\
string  gps_id\n\
float64 gps_time\n\
\n\
# how far to iterate in.\n\
int8 obs\n\
int8[33] prn\n\
\n\
int8[33]    health\n\
\n\
# Positioning\n\
float64[33] semimajor_axis    # sqrt(A), SQUARE ROOT of semi major axis (meters)\n\
float64[33] mean_anomaly      # M0, Mean anomoly of reference time (rad)\n\
float64[33] eccentricity      # ecc, \n\
float64[33] perigee_arg       # omega, Arguement of perigee (rad)\n\
float64[33] cos_latitude      # cuc, Arguement of latitude, amplitude of cosine (rad)\n\
float64[33] sin_latitude      # cus, Arguement of latitude, amplitude of sine (rad)\n\
float64[33] cos_orbit_radius  # crc, Orbit radius, amplitude of cosine (rad)\n\
float64[33] sin_orbit_radius  # crs, Orbit radius, amplitude of sine (rad)\n\
float64[33] cos_inclination   # cic, Inclination, amplitude of cosine (rad)\n\
float64[33] sin_inclination   # cis, Inclination, amplitude of sine (rad)\n\
float64[33] inclination_angle # I0, Inclination angle at reference time (rad)\n\
float64[33] right_ascension   # omega0,  Right ascension (rad)\n\
\n\
# Movement\n\
float64[33] mean_motion_diff  # Delta N, Mean motion difference (rad/s)\n\
float64[33] inclination_rate  # I dot, Rate of inclination angle (rad/s)\n\
float64[33] ascension_rate    # omega0 dot, Rate of right ascension (rad/s)\n\
\n\
# Timing\n\
float64[33] time_of_week      # tow, Time stamp of subframe 0 (seconds)\n\
float64[33] reference_time    # toe, Reference time for ephemeris (seconds)\n\
float64[33] clock_correction  # toc, SV clock correction term (seconds)\n\
float64[33] group_delay       # tgd, Estimated group delay difference (seconds)\n\
float64[33] clock_aging_1     # af0, Clock aging parameter (seconds)\n\
float64[33] clock_aging_2     # af1, Clock aging parameter (seconds/seconds)\n\
float64[33] clock_aging_3     # af2, Clock aging parameter (seconds/seconds/seconds)\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::gps_msgs::Ephemeris_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::gps_msgs::Ephemeris_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.seq);
      stream.next(m.stamp);
      stream.next(m.frame_id);
      stream.next(m.gps_id);
      stream.next(m.gps_time);
      stream.next(m.obs);
      stream.next(m.prn);
      stream.next(m.health);
      stream.next(m.semimajor_axis);
      stream.next(m.mean_anomaly);
      stream.next(m.eccentricity);
      stream.next(m.perigee_arg);
      stream.next(m.cos_latitude);
      stream.next(m.sin_latitude);
      stream.next(m.cos_orbit_radius);
      stream.next(m.sin_orbit_radius);
      stream.next(m.cos_inclination);
      stream.next(m.sin_inclination);
      stream.next(m.inclination_angle);
      stream.next(m.right_ascension);
      stream.next(m.mean_motion_diff);
      stream.next(m.inclination_rate);
      stream.next(m.ascension_rate);
      stream.next(m.time_of_week);
      stream.next(m.reference_time);
      stream.next(m.clock_correction);
      stream.next(m.group_delay);
      stream.next(m.clock_aging_1);
      stream.next(m.clock_aging_2);
      stream.next(m.clock_aging_3);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Ephemeris_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::gps_msgs::Ephemeris_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::gps_msgs::Ephemeris_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "seq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.seq);
    s << indent << "stamp: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.stamp);
    s << indent << "frame_id: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.frame_id);
    s << indent << "gps_id: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.gps_id);
    s << indent << "gps_time: ";
    Printer<double>::stream(s, indent + "  ", v.gps_time);
    s << indent << "obs: ";
    Printer<int8_t>::stream(s, indent + "  ", v.obs);
    s << indent << "prn[]" << std::endl;
    for (size_t i = 0; i < v.prn.size(); ++i)
    {
      s << indent << "  prn[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.prn[i]);
    }
    s << indent << "health[]" << std::endl;
    for (size_t i = 0; i < v.health.size(); ++i)
    {
      s << indent << "  health[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.health[i]);
    }
    s << indent << "semimajor_axis[]" << std::endl;
    for (size_t i = 0; i < v.semimajor_axis.size(); ++i)
    {
      s << indent << "  semimajor_axis[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.semimajor_axis[i]);
    }
    s << indent << "mean_anomaly[]" << std::endl;
    for (size_t i = 0; i < v.mean_anomaly.size(); ++i)
    {
      s << indent << "  mean_anomaly[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.mean_anomaly[i]);
    }
    s << indent << "eccentricity[]" << std::endl;
    for (size_t i = 0; i < v.eccentricity.size(); ++i)
    {
      s << indent << "  eccentricity[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.eccentricity[i]);
    }
    s << indent << "perigee_arg[]" << std::endl;
    for (size_t i = 0; i < v.perigee_arg.size(); ++i)
    {
      s << indent << "  perigee_arg[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.perigee_arg[i]);
    }
    s << indent << "cos_latitude[]" << std::endl;
    for (size_t i = 0; i < v.cos_latitude.size(); ++i)
    {
      s << indent << "  cos_latitude[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cos_latitude[i]);
    }
    s << indent << "sin_latitude[]" << std::endl;
    for (size_t i = 0; i < v.sin_latitude.size(); ++i)
    {
      s << indent << "  sin_latitude[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.sin_latitude[i]);
    }
    s << indent << "cos_orbit_radius[]" << std::endl;
    for (size_t i = 0; i < v.cos_orbit_radius.size(); ++i)
    {
      s << indent << "  cos_orbit_radius[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cos_orbit_radius[i]);
    }
    s << indent << "sin_orbit_radius[]" << std::endl;
    for (size_t i = 0; i < v.sin_orbit_radius.size(); ++i)
    {
      s << indent << "  sin_orbit_radius[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.sin_orbit_radius[i]);
    }
    s << indent << "cos_inclination[]" << std::endl;
    for (size_t i = 0; i < v.cos_inclination.size(); ++i)
    {
      s << indent << "  cos_inclination[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cos_inclination[i]);
    }
    s << indent << "sin_inclination[]" << std::endl;
    for (size_t i = 0; i < v.sin_inclination.size(); ++i)
    {
      s << indent << "  sin_inclination[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.sin_inclination[i]);
    }
    s << indent << "inclination_angle[]" << std::endl;
    for (size_t i = 0; i < v.inclination_angle.size(); ++i)
    {
      s << indent << "  inclination_angle[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.inclination_angle[i]);
    }
    s << indent << "right_ascension[]" << std::endl;
    for (size_t i = 0; i < v.right_ascension.size(); ++i)
    {
      s << indent << "  right_ascension[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.right_ascension[i]);
    }
    s << indent << "mean_motion_diff[]" << std::endl;
    for (size_t i = 0; i < v.mean_motion_diff.size(); ++i)
    {
      s << indent << "  mean_motion_diff[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.mean_motion_diff[i]);
    }
    s << indent << "inclination_rate[]" << std::endl;
    for (size_t i = 0; i < v.inclination_rate.size(); ++i)
    {
      s << indent << "  inclination_rate[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.inclination_rate[i]);
    }
    s << indent << "ascension_rate[]" << std::endl;
    for (size_t i = 0; i < v.ascension_rate.size(); ++i)
    {
      s << indent << "  ascension_rate[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.ascension_rate[i]);
    }
    s << indent << "time_of_week[]" << std::endl;
    for (size_t i = 0; i < v.time_of_week.size(); ++i)
    {
      s << indent << "  time_of_week[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.time_of_week[i]);
    }
    s << indent << "reference_time[]" << std::endl;
    for (size_t i = 0; i < v.reference_time.size(); ++i)
    {
      s << indent << "  reference_time[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.reference_time[i]);
    }
    s << indent << "clock_correction[]" << std::endl;
    for (size_t i = 0; i < v.clock_correction.size(); ++i)
    {
      s << indent << "  clock_correction[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.clock_correction[i]);
    }
    s << indent << "group_delay[]" << std::endl;
    for (size_t i = 0; i < v.group_delay.size(); ++i)
    {
      s << indent << "  group_delay[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.group_delay[i]);
    }
    s << indent << "clock_aging_1[]" << std::endl;
    for (size_t i = 0; i < v.clock_aging_1.size(); ++i)
    {
      s << indent << "  clock_aging_1[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.clock_aging_1[i]);
    }
    s << indent << "clock_aging_2[]" << std::endl;
    for (size_t i = 0; i < v.clock_aging_2.size(); ++i)
    {
      s << indent << "  clock_aging_2[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.clock_aging_2[i]);
    }
    s << indent << "clock_aging_3[]" << std::endl;
    for (size_t i = 0; i < v.clock_aging_3.size(); ++i)
    {
      s << indent << "  clock_aging_3[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.clock_aging_3[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // GPS_MSGS_MESSAGE_EPHEMERIS_H
